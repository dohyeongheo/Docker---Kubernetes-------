# 자체 이미지를 빌드할 때 실행하려는 도커에 대한 명령이 포함된다.

# 따라서 자체 이미지에 대한 설정 명령이 포함된다

# FROM node
# 노드 이미지를 가지고 오는 것으로 시작


# COPY . /app
# COPY .
# 이 프로젝트의 모든 폴더, 하위 폴더 및 파일을 복사
# COPY . .
# 그 파일을 저장해야 하는 이미지 내부의 경로
# 모든 이미지와 이미지를 기반으로 생성된 모든 컨테이너에는 로컬 머신의 파일 시스템에서 완전히 분리된 자체 내부 파일 시스템이 존재
# -> 도커 컨테이너 내부에 숨겨져 있음

# COPY . /app
# 프로젝트의 모든 파일과 하위 폴더가 컨테이너 내부의 app 폴더에 복사됨

# RUN npm install
# RUN npm install은 디폴트로 도커 컨테이너 및 이미지의 작업 디렉토리에서 실행됨
# 디폴트로 그 작업 디렉토리는 컨테이너 파일 시스템의 루트 폴더

# WORKDIR /app
# 도커에게 모든 명령이 사용자가 지정한 폴더에서 실행되어야 한다고 알려주는 방법
# 도커에게 모든 후속 명령이 지정한 폴더 내부에서 실행될 것임을 알림


# FROM node

# WORKDIR /app

# ./는 /app을 가르킴
# COPY . ./

# 절대적으로 명시해주는 것도 가능
# COPY . /app

# RUN npm install

# 마지막 명령은 모든 작업이 완료되면 서버를 시작하기

# RUN node server.js는 이미지가 빌드될때마다 실행되기 때문에 올바르지 않음
# 위의 모든 명령어는 이미지 설정을 위한 도커에 대한 명령
# 이미지는 컨테이너의 템플릿 이어야 함을 명심
# 이미지를 실행하는 것이 아니라, 이미지를 기반으로 컨테이너를 실행하는 것
# 따라서 이 명령을 사용하여 이미지와 템플릿에서 서버를 시작하려고 시도하지만 이는 우리가 원하는 것이 아닙니다. 모든 종속성을 설치하고, 네, 거기에다 모든 코드를 포함하고 싶습니다. 하지만 이미지를 기반으로 컨테이너를 시작하는 경우에만 서버를 시작하고 싶은 겁니다.

# CMD node server.js
# RUN noder sever.js와 CMD node server.js의 차이는 이미지가 생성될 때 실행되지 않고, 이미지를 기반으로 컨테이너가 시작될 때 실행된다는 점

# CMD ["node", "server.js"]
# 배열을 전달
# 도커에게 이미지를 기반으로 컨테이너가 생성 될 때마다 그 컨테이너 내부에 있는 node 명령을 사용하여 server.js 파일을 실행하도록 지시함

# CMD에 특정하지 않으면 베이스 이미지가 실행되며, 그게 없는 경우 에러가 발생함

# 이 노드 웹 서버는 포트 80에서 수신 대기하게 됩니다. 도커 컨테이너가 격리되어 있음을 이미 여러 번 언급하고 강조했죠. 그것은 우리의 지역 환경과 격리되어 있습니다. 결과적으로 자체 내부 네트워크도 있습니다. 컨테이너 내부의 노드 애플리케이션에서 포트 80을 수신할 때 컨테이너는 그 포트를 우리의 로컬 머신에 노출하진 않습니다. 따라서 컨테이너 내부에서만 무언가를 수신 대기 중이기 때문에 그 포트에서 수신할 수 없는 거죠.

# EXPOSE 80
# 우리의 로컬 시스템에 특정 포트를 노출하고 싶다는 것을 도커에 알리는 EXPOSE 80 명령을 추가해야 합니다.  이 컨테이너를 실행할 우리의 로컬 머신에게 말이죠.  그런 후에 이 80 포트를 수신하고 있는 그런 컨테이너를 실행할 수 있게 되는 거죠.

# 최종 Dockerfile 작성은

FROM node

WORKDIR /app

COPY . /app

RUN npm install은

EXPOSE 80

CMD ["node", "server.js"]
